/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/*!
 * \file two_bit_quantize.cc
 * \brief
 */
#include "./two_bit_quantize-inl.h"

namespace mxnet {
namespace op {
DMLC_REGISTER_PARAMETER(TwoBitParam);
NNVM_REGISTER_OP(_contrib_quantize_2bit)
.describe(R"code(Quantize an input tensor using 2-bit compression with residual
array and user-specified threshold.

The quantized_2bit operator takes 5 arguments as follows:
quantize_2bit(array, residual, out, neg_threshold, pos_threshold)`. The `out`
variable will be the compressed array. Note that, the `out` array can be generated by
invoking `create_2bit(array)`.

For example, assume the input array (gradient) is [5.0, -1.0, -5.0, -4.0], and the
residual is [0.0, -2.0, 0, 1.0], and the threshold is -4.0 and +4.0, respectively.
In this method, the elements whose (gradient + residual) >= pos_threshold will be
compressed into 2-bits '01', and the elements whose
(gradient + residual) <= neg_threshold will be
compressed into 2-bits '10'. The other elements will be compressed
into '00', which is represented as zero. Every 16 floats in the
original array will be packed into one float data in output array.

In this example, 'out' has 4 elements. The first element stores the
neg_threshold (-4.0) and the second element stores the pos_threshold (+4.0), the
third element stores the original size of the uncompressed array, and the
original array will be compressed into a single element in the last element.
The residual is also updated to [1.0, -3.0, -1.0, -3.0].
)code" ADD_FILELINE)
.set_num_inputs(3)
.set_num_outputs(0)
.set_attr_parser(ParamParser<TwoBitParam>)
.set_attr<nnvm::FInferShape>("FInferShape", Quantize2BitShape)
.set_attr<nnvm::FInferType>("FInferType", Quantize2BitType)
.set_attr<FCompute>("FCompute<cpu>", Quantize2BitCompute<cpu>)
.set_attr<nnvm::FGradient>("FGradient", ElemwiseGradUseNone{"_quantize_2bit"})
.set_attr<nnvm::FMutateInputs>("FMutateInputs",
[](const nnvm::NodeAttrs& attrs) {
    return std::vector<uint32_t>{1,2};
})
.add_argument("gradient_array", "NDArray-or-Symbol", "A ndarray/symbol of type `float32`")
.add_argument("residual_array", "NDArray-or-Symbol", "A ndarray/symbol of type `float32`")
.add_argument("quantized_array", "NDArray-or-Symbol", "A ndarray/symbol of type `float32`")
.add_arguments(TwoBitParam::__FIELDS__());


NNVM_REGISTER_OP(_contrib_create_2bit)
  .describe(R"code(To generate a compressed array with right shape.
)code" ADD_FILELINE)
  .set_num_inputs(1)
  .set_num_outputs(1)
  .set_attr<nnvm::FInferShape>("FInferShape", Create2BitArrayShape)
  .set_attr<nnvm::FInferType>("FInferType", Create2BitArrayType)
.set_attr<FCompute>("FCompute<cpu>", Create2BitArrayCompute<cpu>)
.set_attr<nnvm::FGradient>("FGradient", ElemwiseGradUseNone{"_create_2bit"})
.add_argument("input", "NDArray-or-Symbol", "A ndarray/symbol of type `float32`");

NNVM_REGISTER_OP(_contrib_dequantize_2bit)
.describe(R"code(Dequantize an input tensor compressed by quantize_2bit.

The dequantize_2bit operator takes two input arguments. The first input is a NDArray,
which has been generated by quantize_2bit(). This operator expects the first
three elements to be the negative threshold, positive threshold, and the size
of the original uncompressed array. Starting from the fourth element are
compressed values of the original array.
The second input is also a NDArray that has the same shape as
the original array before compressing.

Using the example as was described for quantize_2bit

Invoke dequantize_2bit(out, array), the 'array' argument will become
[4.0, 0, -4.0, 0], where -4.0 is the negative threshold.
)code" ADD_FILELINE)
.set_num_inputs(2)
.set_num_outputs(0)
.set_attr<nnvm::FInferShape>("FInferShape", Dequantize2BitShape)
.set_attr<nnvm::FInferType>("FInferType", Dequantize2BitType)
.set_attr<FCompute>("FCompute<cpu>", Dequantize2BitCompute<cpu>)
.set_attr<nnvm::FGradient>("FGradient", ElemwiseGradUseNone{"_dequantize_2bit"})
.set_attr<nnvm::FMutateInputs>("FMutateInputs",
[](const nnvm::NodeAttrs& attrs) {
  return std::vector<uint32_t>{1};
})
.add_argument("quantized_data", "NDArray-or-Symbol", "A ndarray/symbol of type `float32`")
.add_argument("dequantized_data", "NDArray-or-Symbol", "A ndarray/symbol of type `float32`");

}  // namespace op
}  // namespace mxnet
